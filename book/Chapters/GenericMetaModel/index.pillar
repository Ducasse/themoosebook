!The core meta-modelThe core of Moose offers support for storing and manipulating entities in models. The figure below provides an overview of the main classes involved:- Entity \-- representing basic abstract entity representation,- Group \-- representing a group of entities, and- Model\-- a special group that contains all entities relevant for a system.The following sections provide more details about each of these.+Entity, Model, Group>file://figures/moose-entity-model-group.png+!!The EntityThe MooseEntity is the basic representation of an entity in a model. Thus, the MooseEntity class is meant to be subclassed by any specific meta-model entity.It provides two main generic services.First, it holds a reference to the parent MooseModel. This does lead to a cyclic dependency between the entity and the model. However, given the tight connection between these two concepts, it is unproblematic in practice while it provides a particularly handful feature for creating queries that require more information than the current entity provides. For example, suppose that we intend to create a query that given a method entity checks whether another method with the same name appears in the rest of the model. For this, we need to traverse all methods in the model. Having the reference to the model allows us to install a simple method without parameters (i.e., unary method) directly in FAMIXMethod:[[[otherMethodsWithTheSameName   ^ self mooseModel allMethods select: [:each | each name = self name]]]]The second important feature of an entity is the mechanism for state management and extension achieved through the EntityState hierarchy.Following our example, we might want to cache the result of ==otherMethodsWithTheSameName== to not require a new traversal of all methods every time we ask for it. To achieve this, the simplest solution would be to add an instance variable to store the result. However,  extension methods like ==otherMethodsWithTheSameName== are placed typically in a separate package (other than the package of the class), and thus the instance variable should also belong to the same package. This is not cleanly possible in Smalltalk.EntityState solves the situation, by offering for each entity an extensible dictionary that simulates instance variables. For example, we could store the result of our query in a cache:[[[otherMethodsWithTheSameName   ^ self privateState        cacheAt: #otherMethodsWithTheSameName       ifAbsentPut: [         self mooseModel allMethods select: [:each | each name = self name]]]]]Every entity can access its EntityState through the ==privateState== message. There are three dictionaries offered:- attributes \-- for variable extensions that are meant to extend the basic structure of the entity. This typically happens when we want to extend the meta-model with an extra relationship between two entities, we would store it as an attribute. For example, if you would have extra information about which author worked on which method, we could add an author attribute in the Method entity.- cache \-- for storing the result of queries. For example, our example query is meant to be stored in the cache, and not as an attribute.- properties \-- for storing simple values. For example, metrics are typically stored as properties.!!The GroupA Group is an entity representing a collection of entities. For example, we could have a group of class entities, a group of method entities.Groups are important abstractions especially for queries and for user interfaces (see *ref:../../../externals/ui/entity*).@@todo storage@@todo caches and allWithType:@@todo talk about dynamic type changing!!The ModelIn essence a model is the totality of entities and their inter-relationships from a target system. A MooseModel is a special Group.The simplest model is the empty one. You can get it by simply instantiating a MooseModel:[[[ MooseModel new.]]]A model is also an entity, and thus, it can be stored in another model. By default, Moose offers a special root model object that is a singleton and that can be accessed via:[[[ MooseModel root.]]]The root model is special because by convention it is used to store all other models. It acts as a repository, and its content are displayed in the MoosePanel user interface.To add your model to the root model, you can simply do:[[[ | myModel | myModel := MooseModel new. MooseModel root add: myModel.]]]Once an entity is placed in a model, it automatically stores the model in an instance variable accessible via ==mooseModel==. Thus, when a query requires information that is outside of the scope of the entity under study, you can obtain the information from the model.