!Writing parsers with PetitParserPre-existing parsers and importers allow us to deal with well-known languages and data formats. However, in many situations we have to reason about systems written in custom languages or formats.In such situations we need to have the possibility of specifying custom parsers. Moose comes with PetitParser, a parsing framework that enables us to build custom parsers easily.This chapter covers this framework. We start with a hands-on tutorial (see *ref:mse*), and then we move on to looking into the overall design and the various components.!!Step by step parsing of MSETo show how PetitParser works, we take as case study creating a parser to manipulate MSE files. That is right: we pretend Moose has no infrastructure for handling MSE files and we have to create one from scratch.The only input we consider is the official grammar of MSE given using the following rules:[[[Root := Document ?Document := OPEN ElementNode * CLOSEElementNode := OPEN ELEMENTNAME Serial ? AttributeNode * CLOSESerial := OPEN ID NATURAL CLOSEAttributeNode := OPEN SIMPLENAME ValueNode * CLOSEValueNode := Primitive | Reference | ElementNodePrimitive := STRING | NUMBER | BooleanBoolean := TRUE | FALSEReference := IntegerReference | NameReferenceIntegerReference := OPEN REF NATURAL CLOSENameReference := OPEN REF ELEMENTNAME CLOSE]]][[[OPEN := "("CLOSE := ")"ID := "id:"REF := "ref:"TRUE := "true"FALSE := "false"ELEMENTNAME := letter ( letter | digit ) * ( "." letter ( letter | digit ) * ) SIMPLENAME := letter ( letter | digit ) *NATURAL := digit +NUMBER := "-" ? digit + ( "." digit + ) ? ( ( "e" | "E" ) ( "-" | "+" ) ? digit + ) ?STRING := ( "'" [^'] * "'" ) +]]][[[digit := \[0-9] letter := \[a-zA-Z_]comment := """ [^"] * """]]]Based on this, we first want to define a grammar to be able to read the file (see *ref:starting-small*, *ref:manipulating-the-output*, *ref:scripting-grammar* and *ref:grammar-class*). Once able to read, we learn how to test the grammar (see *ref:testing*), and how to build a parser that produces a better output (see *ref:parser*).Further examples can be found at:- *http://www.lukas-renggli.ch/blog/petitparser-1/*- *http://www.lukas-renggli.ch/blog/petitparser-2/*!!!Starting small with parsing namesAs a first task, we parse the identifier names. Looking closely at the MSE grammar, we can find two distinct definitions for identifier names:[[[ELEMENTNAME := letter ( letter | digit ) * ( "." letter ( letter | digit ) * )SIMPLENAME := letter ( letter | digit ) *]]]Let's start with ==SIMPLENAME==. The grammar definition says that a valid name must start with a letter, and afterwards it can be followed by either a letter or a digit repeated multiple times. The same specification can be represented graphically:+MSE workflow>file://figures/petitparser-mse-simple-workflow.png+The translation to PetitParser looks like:[[[simpleName := #letter asParser , ( #letter asParser / #digit asParser ) star.]]]It is that easy. It reads almost like the abstract grammar. In essence, the grammar production is mapped on a parser object, and in this case we store it in the ==simpleName== variable. The parser object is obtained out of terminal parser objects such as ==#letter asParser== for parsing one letter character, or ==#digit asParser== for parsing one digit character. These terminal parsers are composed using operators like ==,== (sequence), ==/== (choice) or ==star== (zero or many). The result is a composite parser whose structure is a graph of objects.+MSE objects>file://figures/petitparser-mse-simple-objects.png+To test our parser we pass it an input string via the ==parse:== method:[[[simpleName parse: 'ValidName'.  "--> #($V #($a $l $i $d $N $a $m $e))"]]]If we print the result we obtain a rather strange looking array that contains each individual character of the input string. We deal with the manipulation of the result at a later time. Currently, we declared ourselves satisfied with getting a valid result.How do we recognize a valid response from an invalid one? Let's give it a try by passing an invalid name:[[[simpleName parse: '1InvalidName'. "-->  letter expected at 0"]]]If we inspect the result, we obtain an instance of ==PPFailure==, which denotes that the parser was not successful in parsing the input. If we only want to test the success of parsing, then we can also use the ==match:== method:[[[simpleName match: 'ValidName'.  "--> true"simpleName match: '1InvalidName'.  "--> false"]]]Having simple name sorted out, we can tackle ==ELEMENTNAME==. It looks slightly more complex and it requires us to specify an optional part that can follow after a dot character. We approach it like we did before and by translating the abstract grammar notation into the PetitParser API.[[[elementName := #letter asParser , ( #letter asParser / #digit asParser ) star ,                (                 $. asParser ,                  #letter asParser , ( #letter asParser / #digit asParser ) star               ) optional.]]]The optional part is specified by simply sending ==optional== to the corresponding parser. Furthermore, to parse the dot character we use ==$. asParser==.At a closer look, we notice the duplication in the above definition. The first part that covers the input until the optional dot is repeated inside the optional part. We could factor it out. Actually, we already have it in ==simpleName==, and we can reuse it:[[[elementName := simpleName , ($. asParser , simpleName) optional.]]]We can test it:[[[elementName matches: 'Valid.Name'. "--> true"elementName matches: '1InvalidName.' "--> false"]]]!!!Manipulating the output of parsing strings and numbersLet us now tackle the parsing of MSE srings and numbers. Valid strings start and end with a single quote character, and in between we should have any non single-quote character:[[[STRING := ( "'" [^'] * "'" ) +]]]The tricky part is expressing ''any character except''. This is achieved through ==negate==. We specify our parser through a sequence in which the contents of the string are given by the parser of single-quote negated and repeated multiple times:[[[string := $' asParser ,           $' asParser negate star ,          $' asParser.]]]A more challenging task would be to add support for escape characters. For example, in MSE, it is allowed to have the character single-quote if it is escaped by another single-quote. The parser could be written as:[[[string := $' asParser ,           ('''''' asParser / $' asParser negate) star ,          $' asParser.]]]The parser now says that either we have two single-quotes one after the other or we do not have any single-quote.Why are there six single-quotes? This happens because the code is written in Smalltalk, and in Smalltalk strings are also marked with single-quotes. For this reason we have two single-quotes surrounding the Smalltalk string, and inside we need to escape the two single-quotes with two more as required by Smalltalk. In total, we get six.We can test the code:[[[string parse: '''string'''.  "--> #($' #($s $t $r $i $n $g) $')"string parse: '''qu''''ote'''.  "--> #($' #($q $u '''''' $o $t $e) $')"]]]The grammar works fine, but the result we obtain is less useful. PetitParser has two major responsibilities: to consume the input according to a grammar, and to transform it into a desired output. Given that the consuming boils down to a traversal of an input stream, the default result is nothing but a nested collection, where the nesting mirrors the specified grammar. For example, ==#($' #($s $t $r $i $n $g) $')== is a Smalltalk array with three elements:- ==$'==, - ==($s $t $r $i $n $g)== which is a nested array produced by ==star==, and- ==$'==.Let us produce a more convenient output in the form of a regular Smalltalk string. First, we want the second element in the resulting array to not be an array but directly a flatten string. For this we have a convenient ==flatten== operator.[[[string := $' asParser ,           ('''''' asParser / $' asParser negate) star flatten ,          $' asParser.]]]The new result looks better:[[[string parse: '''string'''.  "--> #($' 'string' $')"]]]Ultimately, we would want our little parser to ignore the first and the last element and return only the second one. For this, PetitParser offers the possibility to specify a custom transformation through the ==\==>== operator:[[[string := ($' asParser ,           ('''''' asParser / $' asParser negate) star flatten ,          $' asParser)          ==> [ :token | token second ].]]]The transformation operator can be applied to any parser and it takes a block with one argument. The value of the argument is given by the default result of the current parser.In our case, the token argument holds the array ==#($' 'string' $')== and we simply say we want to return the second element. The result is finally what we want:[[[string parse: '''string'''. "--> 'string'"]]]Now, let us move on and create a parser for numbers that produces Smalltalk numbers. For the simplicity of the discussion, let us focus on a smaller grammar:[[[NATURAL := digit +NUMBER := "-" ? digit + ( "." digit + ) ?]]]The correspondent parser can look like:[[[natural := #digit asParser plus.number  := ($- asParser optional , natural , ($. asParser , natural) optional).]]]While the above parser is a direct translation of the grammar definition, we can decompose it better to make the several parts more explicit:[[[natural        := #digit asParser plus. decimalPart    := ($. asParser , natural).positiveNumber := natural , decimalPart optional.negativeNumber := $- asParser , positiveNumber. number         := positiveNumber / negativeNumber.]]]In the end, we want to produce a number. To achieve this we use the transformation blocks for each parser. [[[natural        := #digit asParser plus flatten                   ==> [:token | token asNumber].decimalPart    := ($. asParser , natural)                   ==> [:token | (token at: 2) * (10 raisedTo: (0- (token at: 2) asString size)) asFloat ].positiveNumber := natural , decimalPart optional                   ==> [:token | (token at: 1) + ((token at: 2) ifNil: [0]) ].negativeNumber := $- asParser , positiveNumber                   ==> [:token | 0 - (token at: 2)] .number         := positiveNumber / negativeNumber.]]]We start with the ==natural== parser and simply use the ==asNumber== method available in a Smalltalk string that transforms the contents of the string into a number. From this point on, when the ==natural== parser is used, the output will always be a Smalltalk number, and not a string anymore. Using this approach we can build up the result out of fine grained pieces.One thing to notice is what happens with an optional part. For example, the ==positiveNumber== has an optional ==decimalPart==. This means that if the decimal part is available, the second element in the token array will hold the value of applying the ==decimalNumber== parser to the input, but if the decimal part is missing, the corresponding value will be ==nil==. Thus, we typically have to guard the manipulation of an optional part with an if in the transformation block. In our case, we want ==0== when no decimal part is specified.One way to go around the use of an optional is to use the choice parser combinator (i.e., ==/==). For example, even if in the original grammar there are two optional productions (i.e., one for the sign, and one for the decimal part) in the transformation blocks we have only one if. This happens because we modeled the optional sign in a ==number== with a choice between a ==positiveNumber== and a ==negativeNumber==. While both approaches can have their benefits, it is important to know of their existence and choose the one that better fits the problem at hand.!!!Dealing with cyclic dependencies when scripting the MSE grammarIn *ref:../starting-small* we see in details how we approach the definition of parsers to deal with the names. Once the grammar is clear, the process is straightforward and can be repeated for any production rules.The full MSE parser can be seen below.[[[open := $( asParser trim.close := $) asParser trim.string := ($' asParser ,           ('''''' asParser / $' asParser negate) star flatten ,          $' asParser) trim.natural := #digit asParser plus flatten.e :=  ($e asParser / $E asParser) , ($- asParser / $+ asParser) optional , natural.number := ($- asParser optional , natural ,           ($. asParser , natural , e optional) optional) flatten trim.boolean := ('true' asParser / 'false' asParser) flatten trim.primitive := string / number / boolean.simpleName := #word asParser star flatten.elementName := (simpleName , ($. asParser , simpleName) optional) token trim.nameReference := (open , 'ref:' asParser , elementName , close) token.integerReference := (open , 'ref:' asParser , natural trim , close) token.reference := integerReference / nameReference.element := PPUnresolvedParser new.attributeValue := (primitive / reference / element) star.attribute := (open , simpleName , attributeValue , close) trim.id := (open , 'id:' asParser , natural trim , close) trim.element def: ( (open , elementName , id optional , attribute star , close) trim).elements := open , element star , close.start := elements end.]]]You can test the parser with a valid MSE string:[[[mseString := '(  (FAMIX.Package      (name ''PackageP''))  (FAMIX.Class     (name ''ClassA''))  (FAMIX.Method     (name ''methodM'')))'.start parse: mseString]]]A particularity of this example is the use of PPUnresolvedParser. When scripting a grammar, every production is held in a parser variable. However, in our case, we have cyclic definitions: - the ==element== parser depending on the ==attributeValue== parser (through ==attribute==), and- the ==attributeValue== parser depending on the ==element== one.This is the case where PPUnresolvedParser comes to the rescue. We first define one of the parser as undefined, refer to it from the second parser, and then we define the first rule using ==def:==.This example provides a good coverage of the various operators available in PetitParser. More detailed information about these can be found in *ref:../../operators*.!!!Encapsulating the MSE grammar in a classScripting a parser is fast, but it can also get dirty. In fact, for any parser that has more than a handful of sub-parsers, it typically gets too dirty.To solve the situation, PetitParser also offers the possibility of mapping a parser on a class. The idea is quite simple:- the class must be a subclass of ==PPCompositeParser==, and it holds the complete parser,- the methods of the class provide the productions, and- the attributes of the class store the actual sub-parsers.Let us take our example of producing an MSE grammar. We first create the class.[[[PPCompositeParser subclass: #ExampleMSEGrammar  instanceVariableNames: ''  classVariableNames: ''  poolDictionaries: ''  category: 'MSEParserExample']]]Afterwards, we take each production from the script and we transform it in a method. For example:[[[start := elements end.]]]gets transformed into:[[[start   ^ elements end]]]This might look odd at first sight. Indeed, there is a little magic going on behind the scene. Let us take a closer look.For every production, we create a method. In this case we create the ==start== method, which happens to be mandatory for telling the parser from which production it should start by default.The odd thing is that in the method we refer directly to the ==elements== production via an instance variable (i.e., instead of calling a method). This happens because the PPCompositeParser uses reflection to lookup the corresponding method and to store the result in the instance variable. This leads to a better performance when the same production is used in two different places.Given that we now refer to the ==elements== instance variable, we also have to create the corresponding method. To do this, we simple copy the production from the script:[[[elements  ^ open , element star , close.]]]Repeating these steps for all the productions from the script, we obtain our grammar class. Afterwards, we can execute a parsing command via:[[[mseString := '(  (FAMIX.Package (id: 1)      (name ''PackageP''))  (FAMIX.Class (id: 2)      (name ''ClassA'')     (parentPackage (ref: 1)))  (FAMIX.Method (id: 3)     (name ''methodA'')     (declaredType (ref: 1))     (parentType (ref: 2))))'.ExampleMSEGrammar parse: mseString]]]!!!Testing the MSE grammar classParsers can get complex quite quickly. For example, the MSE grammar developed previously (see *ref:../grammar-class*) even if rather small, it is reasonably intricate as can be seen in the graph below:+MSE Grammar>file://figures/petitparser-mse-grammar-graph.png+In this situation testing becomes central for controlling the evolution of the parser. Given its importance, PetitParser offers a dedicated infrastructure similar to the one for creating parsers.To create a test case, we first create a subclass of PPCompositeParserTest:[[[PPCompositeParserTest subclass: #ExampleMSEGrammarTest  instanceVariableNames: ''  classVariableNames: ''  poolDictionaries: ''  category: 'MSEParserExample']]]In this test class, we override the ==parserClass== method to return the target parser to be tested:[[[ExampleMSEGrammarTest>>parserClass  ^ ExampleMSEGrammar]]]Afterwards, each test method should be focused on testing one example for one production. For writing the assertion, the base test class offers a utility ==parse:rule:== that checks that the string passed as the first argument is parse-able using the production passed as the second argument. For example, for testing the element name we can write:[[[ExampleMSEGrammarTest>>testElementName  self parse: 'ABC.XYZ' rule: #elementName]]]!!!Creating an MSE parserThe grammar provides a means to digest the input from a syntactic point of view. The default result of parsing the input using this grammar is an array. In most cases this array is not at all satisfactory. Instead, we need to produce an output that matches our problem.Let us consider using the MSE grammar from *ref:../grammar-class* for a simple input.[[[mseString := '((FAMIX.Package))'.ExampleMSEGrammar parse: mseString."-->  an Array($( an Array(an Array($( a PPToken(FAMIX.Package) nil #() $))) $))"]]]Let us supposed that we merely want to produce a regular Smalltalk nested array out of input. There is a lot of unwanted cruft that we would like to get rid of, such as not printing ==a PPToken== explicitly, but only get the name of the element.To solve this problem, we subclass the grammar class with a parser class that will take care of the desired transformation.[[[ExampleMSEGrammar subclass: #ExampleMSEArrayParser  instanceVariableNames: ''  classVariableNames: ''  poolDictionaries: ''  category: 'MSEParserExample']]]Before we go any further, we write a test. To do this we mirror the hierarchy of parsers with a hierarchy of tests:[[[ExampleMSEGrammarTest subclass: #ExampleMSEArrayParserTest  instanceVariableNames: ''  classVariableNames: ''  poolDictionaries: ''  category: 'MSEParserExample']]][[[ExampleMSEArrayParserTest>>testElementName  super testElementName.  self assert: result = 'ABC.XYZ']]]The first line, simply calls the test defined in the super class (see *ref:../testing*). Because the test stores the parsing result result in the ==result== instance variable, we can use this instance variable for writing the assertion.The test fails as expected. To make it work, we now have to override the ==elementName== definition in the parser class and specify how the output should be transformed:[[[ExampleMSEArrayParser>>elementName  ^ super elementName  ==> [:token | token value ]]]]The output transformation is achieved through the ==\==>== operator. This operator takes as input the value returned by the parser and returns the result of evaluating the block. In this case, we simply want to extract the string value out of the token object.With this change, the test becomes green, and running the example yields:[[[mseString := '((FAMIX.Package))'.ExampleMSEArrayParser parse: mseString."-->  an Array($( an Array(an Array($(FAMIX.Package nil #() $))) $))"]]]!!Parsing operatorsPetitParser is based on scannerless parsing. This means that even the most basic of parsers are parsers too. PetitParser offers several of these basic parsers, also called terminals. Here are some examples:|!Terminals |! Description| ==$a asParser== | Parses the character $a.| =='abc' asParser== | Parses the string 'abc'.| ==#any asParser== | Parses any character.| ==#digit asParser== | Parses the digits 0..9.| ==#letter asParser== | Parses the letters a..z and A..Z.| ==#cr asParser== | Parses the carriage-return character.| ==#lf asParser== | Parses the line-feed character.| ==#space asParser== | Parses the space character.| ==#tab asParser== | Parses the tabulator character.| ==nil asParser== | The empty parser.More readily available terminals can be found on the class side of the ==PPPredicateObjectParser== class, in the ==factory-chars== protocol.|!Combinators |!Description| ==p1 , p2== | Parses p1 followed by p2 (sequence).| ==p1 / p2== | Parses p1, if that doesn’t work parses p2 (ordered choice).| ==p star== | Parses zero or more p.| ==p plus== | Parses one or more p.| ==p optional== | Parses p if possible.|!Predicates |!Description| ==p and== | Parses p but does not consume its input.| ==p not== | Parses p and succeeds when p fails, but does not consume its input.| ==p negate== | Parses any input token but the receiver.| ==p end== | Parses p and succeeds at the end of the input.To manipulate the output of a parser, PetitParser offers actions that we can use to decorate the parser.|!Actions |! Description| ==p \==> aBlock== | Performs the transformation given in aBlock.| ==p flatten== | Creates a string from the result of p.| ==p token== | Creates a token from the result of p.| ==p trim== | Trims all whitespaces before and after p.| ==p trimBlanks== | Trims the blanks before and after p.!!Dedicated user interfaceIf you want to visualize, edit, or debug the parser, you can use the built-in editor by:[[[PPBrowser open]]]+PetitParser browser>file://figures/petitparser-browser.png+