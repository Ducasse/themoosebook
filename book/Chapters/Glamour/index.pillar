@cha:Glamour!Building browsers with GlamourLarge models hold many details. Tons of details. It is precisely this sheer size that makes it can be hard for us to grasp all these details in one shot. Browsers offer an alternative. A browser is a specific user interface that allows us to look at the space provided by the model, to navigate from one part of this space to another, and to act upon it.For example, both the Inspector and the Moose Finder are browsers. They have a workflow that works well for many situations, but this workflow is still hardcoded and at times it is not flexible enough to accommodate custom needs. An alternative way is to use a custom browser. For example, when it comes to manipulating code, we could write code in the Inspector, but we typically prefer not to. We use a dedicated code browser instead.Dedicated browsers are desirable, but they are typically expensive to build. As a result we have no dedicated way to browse the large majority of models around us. This situation needs rectification, and Glamour presents the solution in the form of an engine for building dedicated browsers. In fact, the Inspector and the Moose Finder are written in Glamour.This chapter describes the details of Glamour. It starts with a short tutorial and then it gradually introduces the architecture and the most important concepts.!!A glimpse of GlamourHow exactly does Glamour help us build dedicated browsers? The rest of this section tries to answer this question via a hands-on example.Previously, we saw that the  ==ArgoUML-0-34== system is comprised of several submodules identified by the presence of a ==build.xml== file in the folder. To get a better handling of these build files, we construct a dedicated browser for them. For example, we can show all modules to the right, and the details related to the build file of each module to the right. +Simple build browser>file://figures/glamour-action-1.png+From a conceptual point of view, this browser is composed out of two panes that are connected such that when we select something in the first one, the second pane shows related information.Let's construct this step by step. Open a Playground and type:[[[GLMCompositePresentation new tabulator 	with: [ :t |		t column: #index; column: #details.		t transmit to: #index; andShow: [ :composite | 			composite list 				title: 'Projects';				format: [:each | each parent basename]] ];	openOn: (MooseModel root allModels anyOne rootFolder asFileReference allFiles select: [ :each | each basename = 'build.xml' ]).]]]+Browser with one list>file://figures/glamour-action-2.png+We build a browser with two panes: ==#index== and ==#details==. When opening the browser, we transmit to the ==#index== pane the input and we show in the pane a list presentation that is entitled =='Projects'==. The list also formats its elements by showing only the basename of the parent directory. We open the overall browser on the list of all build files. One thing to notice here is that we focus primarily on how data flows, and only afterwards on how it is presented.Still, nothing happens when selecting an item from our list. That's because we did not connect the two panes. Let's connect them.[[[GLMCompositePresentation new tabulator 	with: [ :t |		t title: 'Build browser'.		t column: #index; column: #details.		t transmit to: #index; andShow: [ :composite | 			composite list 				title: 'Projects';				format: [:each | each parent basename] ].		t transmit from: #index; to: #details; andShow: [ :composite |			composite text				title: 'XML';				display: [ :file | file contents ] ] ];	openOn: (MooseModel root allModels anyOne rootFolder asFileReference allFiles select: [ :each | each basename = 'build.xml' ] )			]]]The second transmission connects the selection from ==#index== with the input from ==#details== and it shows a text that displays the contents of the file.+Browser with two connected panes>file://figures/glamour-action-3.png+We can now also add extra presentations with more details in the second pane. [[[GLMCompositePresentation new tabulator with: [ :t |	t column: #index; column: #details.	t transmit to: #index; andShow: [ :composite | 		composite list			title: 'Projects';			format: [:each | each parent basename] ].	t transmit from: #index; to: #details; andShow: [ :composite |		composite text			title: 'XML';			display: [ :file | file contents ].		composite list 			title: 'Targets';			display: [ :file | (XMLDOMParser parse: file contents) // 'target' ];			format: [ :xmlElement | xmlElement attributeAt: 'name' ].		composite roassal2			title: 'Dependencies';			initializeView: [ RTMondrian new ];			painting: [ :view :file | 				| tags |				tags := (XMLDOMParser parse: file) // 'target'.				view shape label text: [:each | (each @ 'name') stringValue].				view nodes: tags.				view shape line color: (Color gray alpha: 0.5).				view edges connectFromAll:  [:aTag | |depends|					depends:=(aTag @ 'depends') stringValue splitOn: ', '.					tags select: [ :each | 						depends includes: (each @ 'name') stringValue] ].				view layout horizontalDominanceTree.				] ].	];	openOn: (MooseModel root allModels anyOne rootFolder asFileReference allFiles select: [ :each | each basename = 'build.xml' ]).]]]In this case, one of the presentation is another list showing only the ==<target>== tags from the build files, and another presentation is a Roassal visualization showing the dependencies between the ==<target>== tags.+Browser with two connected panes and multiple presentations>file://figures/glamour-action-4.png+Not bad so far. Still, why should we see the XML details only for the overall file? Why not see the XML of the tags as well?Let's transform a bit our browser:[[[GLMCompositePresentation new tabulator with: [ :t |	t title: 'Build browser'.	t 		row: [:r | r column: #index; column: #details];		row: #source.	t transmit to: #index; andShow: [ :composite | 		composite list			title: 'Projects';			format: [:each | each parent basename] ].	t transmit from: #index; to: #details; andShow: [ :composite |		composite list 			title: 'Targets';			display: [ :file | (XMLDOMParser parse: file contents) // 'target' ];			format: [ :xmlElement | xmlElement attributeAt: 'name' ].		composite roassal2			title: 'Dependencies';			initializeView: [ RTMondrian new ];			painting: [ :view :file | 				| tags |				tags := (XMLDOMParser parse: file) // 'target'.				view shape label text: [:each | (each @ 'name') stringValue].				view nodes: tags.				view shape line color: (Color gray alpha: 0.5).				view edges connectFromAll:  [:aTag | |depends|					depends:=(aTag @ 'depends') stringValue splitOn: ', '.					tags select: [ :each | 						depends includes: (each @ 'name') stringValue] ].				view layout horizontalDominanceTree.				] ].		t transmit from: #index; to: #source; andShow: [ :composite |			composite text				title: 'XML';				display: [ :file | file contents ] ].		t transmit from: #details; to: #source; andShow: [ :composite |			composite text				title: 'XML';				display: [ :xmlElement | xmlElement gtDisplayString ] ].				];	openOn: (MooseModel root allModels anyOne rootFolder asFileReference allFiles select: [ :each | each basename = 'build.xml' ])]]]Now, we created an extra pane named ==#source== and we transmit to it both from the ==#index== pane and from the ==#details== pane.+Browser with separate XML preview>file://figures/glamour-action-5.png+That is about it.@@note In short, in Glamour get five main concepts: a ''browser (1)'' is made of ''panes (2)'' which represent spatial locations on which various ''objects (3)'' are ''presented (4)''. Furthermore, the result of acting on the graphical ''presentation (4)'' is ''transmitted (5)'' to other panes.!!Glamour architectureThe architecture of Glamour revolves around a handful of concepts. The picture below shows a UML diagram with an overview of these.+file://figures/glamour-architecture.png+The central concept is the Browser which encapsulates the entire interaction and presentation logic of a browser.A Browser is composed of Panes. A pane defines physical locations in a Browser. A Pane manages its state through named Ports which can hold any objects as value. The navigation flow is specified via Transmissions. A Transmission connects several origin ports with a destination port, and its job is to handle the propagation of values between these. In essence, when the value of an origin port changes the Browser analyzes its Transmissions and those that originate in that particular port are subject to being triggered.Essentially, the constructs of Panes, Ports and Transmissions correspond to a components and connectors architecture in which the components are connected in a directed graph.Panes only define the location in the Browser, but the way they should be rendered is handled by Presentations. A Presentation interprets the state of the Pane and maps it to visual characteristics through a strategy pattern. Thus, we can have multiple types of Presentations: TextPresentation, ListPresentation and so on.Furthermore, Presentations can also be composed in a CompositePresentation. In fact, a Pane is always represented by such a composite.!!Sketching browsersTo ease the conception of browsers we can use a dedicated notation to capture the critical aspects: Pane, Port, Transmission and Presentation (and Browsers). A sketch of a browser and the corresponding legend can be seen below.+file://figures/glamour-notation.png+The flow of a browser can soon become complex and difficult to follow. This notation is meant to be used during the process of designing the browser to untangle this complexity.@@note Use this even for simple browsers. Before coding a browser, start by sketching it on a paper. This will help you crystalize the way the information flows through your browser.!!Handling transmissionsThe fundamental idea behind Glamour starts from the observation that the navigation flow should be orthogonal to the way of presentation. In Glamour, this navigation flow is captured through Panes, Ports and Transmissions: the Panes represent the building blocks, the Ports provide the hooks, and the Transmissions form the fiber of the browser by connecting the ports.The following UML class diagram shows the most important classes and methods related to understanding Transmissions. A Transmission connects a destination port with one or multiple origin Ports. When triggered, the main job of the Transmission is to take the values from the origin ports and combines them to populate the destination port. Further behavior can be appended to this basic one through a transmission strategy.An origin port can be either active (specified using ==from:port:==) or passive (specified using ==passivelyFrom:port:==). Only the active origin ports can trigger a transmission. This information is captured by the PortReference.@@todo explain what is the use of a passive portAs mentioned, a Transmission can have several origin ports. This is achieved by sending multiple messages like ==from:port:==. As a result of triggering a transmission with multiple origins, the target port contains a special ordered collection populated with the values from the origins. These values are then accessible when defining the properties of the desired presentations.In most cases transmissions originate in a ==#selection== port and have as destination an ==#entity== port. For convenience, Glamour provides some shorter messages that make use of this observation:- For specifying a transmission origin that points to a ==#selection== port of a pane, you simply use ==from:==.- Similarly, for specifying a transmission destination that points to an ==#entity== port of a pane, you can use ==to:==.The triggering of a Transmission can be controlled by a condition specification. This condition is set via a ==when:== message that takes as a parameter a block returning a boolean depending on the values of the origin ports.Transmissions have deep control over the values passed around via transformation specifications. There are two hooks for such transformations.The main transformation is offered by the Transmission itself and it comes in the form of a block that takes as parameters the values from the origin ports and returns the desired value to be set in the destination port. This can be specified via a ==transformed:== message sent to the transmission.The second hook is provided by the PortReference. Using this transformation, we can transform each individual port before it gets in the Transmission transformation. We can specify such a transformation for each individual origin port using ==from:transformed:== or ==passivelyFrom:transformed:==. Besides setting the value to a destination port, a Transmission can have further behavior via a TransmissionStrategy. This is useful when we want the transmission to also impact the presentations from the pane of the target destination. Besides the NoStrategy default strategy, there are two more semantics presently implemented:# ReplacePresentationsStrategy replaces the presentations from the pane of the destination port with those specified by the strategy. This one is set via the ==andShow:== message.# PresentIfNoneStrategy sets presentations only if none exits in the pane of the destination port. This one is set via the ==andShowIfNone:== message.Both the ==andShow:== and the ==andShowIfNone:== messages expect a block with one parameter consisting of a composite presentation that will be used by the transmission.+file://figures/transmission-semantics.png+The following pieces of code offer some examples of the most common cases of transmissions:[[["transmission with multiple origins that replaces presentations"browser transmit   from: #paneOne;  from: #paneTwo port: #portB;  to: #paneThree;  andShow: [ :a |     "specification of presentations based on two variables" ].]]][[["transmission that installs a presentation only if none exists in the target panel"browser transmit   from: #paneOne;  to: #paneTwo;  andShowIfNone: [ :a |     "specification of presentations" ].]]][[["transmission with multiple origins and with transformations"browser transmit   from: #paneOne transformed: [ :paneOneSelectionValue |     "computation of the transformed value based on one variable" ];  from: #paneTwo port: #portB;  to: #paneThree;  transformed: [ :transformedPaneOneSelectionValue :portBValue |    "computation of the destination value based on two variables" ]]]][[["transmission with one origin bound to the pane surrounding the browser (i.e., the outside port)"browser transmit   fromOutsidePort: #outsidePort;  to: #paneThree port: #portC.]]][[["transmission with the origin bound to the #entity port of the pane of the browser"browser transmit   to: #paneThree port: #portC.]]]!!Specifying presentationsA Presentation defines the way a Pane is to be displayed and how the user interaction should change its state. It does that by interpreting the values from the Ports and by specifying how these Ports should change.Presentations can be parameterized in several ways using blocks. The basic parameters are:- Every presentation has a title set via ==title:==.- A presentation can transform the input into a model better suited for it. This is accomplished via the ==display:== message.- The visibility of each presentation can be controlled via a condition block that is set by sending a ==when:== message. - By default, there is an implicit condition saying that all input objects must be not nil for the presentation to appear. If we still want to allow the presentation to appear even if the the input objects are nil we can use ==allowNil==.All these specifications take as input blocks that accept a variable number of parameters depending on the number of objects present in the ==#entity== port. In our example, we only used transmissions with one origin, and thus the display blocks took one parameter as input. For example, the code below describes how on the ==#details== pane we should show a TextPresentation that should ==display:== the result of a block that takes as parameter the ==#selection== from the ==#methods== pane, and this in turn happens to be a method entity which understands ==sourceText==.[[[browser transmit from: #methods; to: #details; andShow: [ :composite |  composite text    display: [ :method | method sourceText ] ].]]]If on the other hand, we might want to be able to show the source code for both a class and a method, we could write:[[[| browser |" ... "browser transmit  from: #classes;  from: #methods;   to: #details; andShow: [ :composite |    composite text      title: [ :class | class name, ' source'];      display: [ :class | class sourceText ];      allowNil.    composite text      title: [ :class :method | method name, ' source'];      display: [ :class :method | method sourceText ] ].]]]Because now we have two origins, there will be two objects in the #entity port corresponding to the selected class and to the selected method. Thus, the ==display:== block of the presentations  accepts two parameters. However, when we only need the first one we can leave the second one out, as is the case for displaying the class source text. Furthermore, because we want to display the class source even when no method is selected, we want to allow the presentation to appear even when one of the ports is nil.Glamour offers multiple types of presentations, and the figure below shows an overview. Some of these correspond to basic widgets that can be found in user interface frameworks, while others are more sophisticated and tailored for the needs of browsing. The following section describe each of them.+file://figures/glamour-presentations-details.png+@@todo clarify how presentations consume and populate ports!!!Composite presentationEvery pane has a reference to a Composite Presentation. Thus, whenever we specify a transmission, we get access to such a composite presentation.[[[| browser | " ... "browser transmit from: #paneOne; to: #paneTwo; andShow: [ :composite |  "composite is a CompositePresentation that will be installed on the destination pane" ].]]]The job of a composite is to regulate the display of the contained presentations. To this end, it allows us to specify a so called arrangement.There are three different kinds of arrangements currently offered:- TabbedArrangement arranges multiple presentations under a tab widget. This is the default arrangement.- StackedVerticallyArrangement lays out the presentations one below the other in group boxes.- AccordionArrangement offers the possibility to collapse the presentations using an accordion widget.Specifying the arrangement is straightforward. For example:[[[| browser | " ... "browser transmit from: #paneOne; to: #paneTwo; andShow: [ :composite |  composite stackedVerticallyArrangement.  "..." ].]]]!!!Listing presentationsThere are three ListingPresentations available: List, Tree and Table. Each of these expects the result of evaluating the transformation on a given input entity (by using ==display:==) to be a list.In the case of the ListPresentation, this list is then mapped on the elements in the list widget to be displayed. For example, to display the namespaces from a MooseModel in a list you can use:[[[browser transmit to: #namespaces; andShow: [ :composite |   composite list      display: [ :model | model allNamespaces ] ].]]]A TablePresentation goes along the same line, only it adds the possibility to also add columns using ==column:evaluated:==. For example, if we want to display the number of classes in each namespace, we can do it like:[[[browser transmit to: #namespaces; andShow: [ :composite |   composite table      display: [ :model | model allNamespaces ];      column: 'Namespaces' evaluated: [ :each | each mooseName ];      column: 'NOCls' evaluated: [ :each | each classes size asString ] ].]]]A TreePresentation is slightly different. The list to be displayed will appear as root elements in the tree. Thus, if we want to show the tree of all namespaces, in the display block we have to select only the root ones and then specify the children (using ==children:==) for each of the namespaces:[[[browser transmit to: #namespaces; andShow: [ :composite |   composite tree      display: [ :model | model allNamespaces select: [ :each | each isRoot ] ];      children: [ :namespace | namespace childScopes ] ].]]]The ListingPresentations also offer further options. First, we can specify how to deal with the selection. In this area we can say if we want the selection to ==beSingle== (the default option) or to ==beMultiple==. When multiple selection is wanted, the result of populating the ==#selection== port is a collection. Yet another selection related issue is to ==allowDeselection== of the current selection. If the listing is set to allow deselection, when deselecting the ==#selection== port is set to ==nil==.Second, we have the possibility to ask for an input box that acts as a filter (using ==filterOn:==) or as a search box (using ==searchOn:==). Both accept as parameter a block that takes each element of the list as input and returns a true or false. The effect of the filter box is to trim the visible items based on the selection. The effect of the search box is to select the desired item and to populate the ==#selection== port. For example, in the Moose Finder (see *ref:../../../../externals/ui/finder*) the group view offers a search box with which we can select the wanted elements in the group. Once selected, the ==#selection== port is populated appropriately.Third, it is sometimes impractical to show an entire list, especially when we deal with very large lists. In such situations it is better to show only a limited amount of items by using ==showOnly:==. For example, this can be seen in the Moose Finder where we typically do not show more than 50 elements by default.Finally, we also have the possibility to add tags to the items of a list by using ==tags:==.@@todo icon@@todo input and output ports: #selection, #strongSelection, #selectedPath!!!Text presentationA TextPresentation offers the possibility to display a text in an editor. For example, suppose we have a class at hand, we can display the source code in the following way:[[[browser transmit to: #source; andShow: [ :composite |   composite text      display: [ :class | class sourceText ] ].]]]The presentation offers control over the setting and retrieving the currently selected text. The selected text is provided via the port named ==#selectedText==. It is not provided through the --==#selection==-- port, because in most cases, it is not text that we want as an abstraction to pass forward to other ports. Furthermore, we can also set the currently selected text through the ==#selectionInterval== port.!!!Label presentationA Label Presentation displays a non-interactive label as a piece of text that should fit on one line. To specify, simply use a piece of code along the lines of:[[[  composite label display: [ :entity | 'A label example' ].]]]Labels typically go well with a fix-size pane. For example:[[[| browser |browser := GLMTabulator new.browser row: #variable; row: #fix size: 20.browser transmit to: #fix; andShow: [ :composite | composite label display: 'Fix size'].browser showOn: #variable; using: [browser text display: 'Variable size'].browser openOn: 1 ]]]!!!Smalltalk code presentationThe SmalltalkCode presentation is a specialization of the TextPresentation that provides handy features for handling Smalltalk code: syntax highlighting and code completion.There are two modes in which this presentation can be used:# by default, the presentation behaves like a Smalltalk Workspace, and it highlights the code as if it were written in the Smalltalk Workspace.# by specifying a ==smalltalkClass:== you can specialize it and make it behave as a method code editor. This property takes as parameters the entity objects and its evaluation is expected to produce a Smalltalk class. As a result the code will be highlighted as if it were a method definition inside the specified class.When in the Workspace mode, you can also specify variable bindings that can be passed to the overall context. This is achieved by getting the ==variableBindings:== return a collection of associations in which each key is the name of the variable, and each value is the value of the corresponding variable.An example of a simple Smalltalk code can be seen below:[[[| browser |browser := GLMTabulator new.browser row: #code span: 2; row: #preview.browser transmit to: #code; andShow: [ :composite |   composite smalltalkCode     title: 'Smalltalk Code';    populate: #acceptedCode      icon: GLMUIThemeExtraIcons glamorousAccept      on: $s       entitled: 'Accept'      with: [:text | text text ] ].browser transmit from: #code port: #acceptedCode; to: #preview; andShow: [ :composite |   composite text     title: 'Evaluated result';    display: [:code | [Compiler evaluate: code ] on: Error do: ['Error']] ].browser openOn: '1+2']]]!!!Roassal presentation@@todo refactor this for RoassalThe RoassalPresentation offers the means to integrate a Roassal view inside a browser.The presentation can simply be customized through a ==painting:== block that takes a ==view== variable as a first parameter and the entity variables as the following parameters. Let's see an example of building a simple browser with two panes showing a System Complexity to the left and for each selected class displaying a Class Blueprint to the right:[[[| browser |browser := GLMTabulator new.browser title: 'Complexity Previewer'.browser column: #complexity span: 3; column: #blueprint.browser transmit to: #complexity; andShow: [:composite |   composite roassal2     painting: [ :view :model |       (model allModelClasses reject: #isInterface) viewSystemComplexityOn: view ]].browser transmit from: #complexity; to: #blueprint; andShow: [:composite |   composite roassal2     painting: [ :view :class |       class viewBlueprintOn: view ];    whenKindOf: FAMIXClass ].]]]+mondrian-example+In the above code, we made use of the already provided Mondrian scripts found in ==FAMIXClassGroup>>viewSystemComplexityOn:== and ==FAMIXClass>>viewBlueprintOn:==. Both of these accept an instance of a ==ViewRenderer== as a parameter, so we can simply pass them the ==view== variable received in the block (see *ref:../../../mondrian/scripting/conventions* for more details about Mondrian scripts).The MondrianPresentation populates the ==#selection== port with the object behind the selected element. Furthemore, populating the ==#selection== port from outside leads to selecting the element with the corresponding object behind.!!!Magritte presentationMagritte is a framework for meta-describing data, and one of its applications is the automatic generation of user interfaces for handling data. An extensive description of the concepts of Magritte is provided at: *http://book.seaside.st/book/advanced/magritte*.All that is required by the Magritte engine is a description for each of the handled entities. Thus, the MagrittePresentation expects the evaluation of the ==display:== block to return an object that can be used for the model behind the ==description:==. Once the description obtained, it is simply passed to Magritte and the engine takes care of the rendering.As an example, let us set our mind to create a small tool to help us review source code. More specifically, we want for each class we inspect in the code browser to have a small form that enables us to write a comment and to mark the class as problematic.We first need the class that will hold the review information. Thus, we create ==TMBReview== class that holds a comment and problematic instance variables:[[[Object subclass: #TMBReview    instanceVariableNames: 'comment problematic'    classVariableNames: ''    poolDictionaries: ''    category: 'TheMooseBook-Examples']]][[[TMBReview>>comment  ^ comment]]][[[TMBReview>>comment: aString  comment := aString]]][[[TMBReview>>problematic  ^ problematic]]][[[TMBReview>>problematic: aBoolean  problematic := aBoolean]]]The next step is to make this class Magritte aware:[[[TMBReview class>>descriptionComment  ^ MAStringDescription new        accessor: #comment;        label: 'Comment';        priority: 100;        yourself]]][[[TMBReview class>>descriptionProblematic ^ MABooleanDescription new        accessor: #problematic;        label: 'Problematic';        priority: 200;        yourself]]]Once we have that, we can just go ahead and build our browser:@@todo replace this example with the XML one[[[| browser |browser := GLMTabulator new.browser title: 'Reviewer'.browser  row: [ :r | r column: #namespaces; column: #classes; column: #methods ];  row: [:r  | r column: #details span: 2; column: #review ].browser transmit to: #namespaces; andShow: [ :composite |  composite tree    display: [ :model | model allNamespaces select: [ :each | each isRoot ] ];    children: [ :namespace | namespace childScopes ];    format: [ :namespace | namespace stubFormattedName ] ].browser transmit from: #namespaces; to: #classes; andShow: [ :a |  a list    display: [ :namespace | namespace classes ];    format: [ :class | class stubFormattedName ] ].browser transmit from: #classes; to: #methods; andShow: [ :a |  a list    display: [ :class | class methods ];    format: [ :method | method stubFormattedName ] ].browser transmit from: #classes; from: #methods; to: #details; andShow: [ :a |  a text    title: [ :class | class name, ' source'];    display: [ :class | class sourceText ];    allowNil.  a text    title: [ :class :method | method name, ' source'];    display: [ :class :method | method sourceText ] ].browser transmit from: #classes; to: #review; andShow: [:a |   a magritte     title: 'Review';    display: [ :class |      | review |      review := class propertyNamed: #theReview ifAbsentPut: [TMBReview new].      review ];    description: #description].]]]For obtaining the review information for each class, we make use of the generic ==propertyNamed:ifAbsentPut:== method present in any Moose entities. Using this, we lazily create a review object if none exists for the current class. We then pass the ==description== of this object to be rendered.Executing the script leads to a browser like in the screenshot below:+file://figures/glamour-magritte-presentation.png+!!!Diff presentationA DiffPresentation expects a collection with two pieces of text from the ==display:== block, and it displays the difference between these with a dedicated user interface widget.A simple use case can be encountered when browsing a collection of Duplication entities computed by SmallDude (see *ref:../../../../externals/smalldude*). Duplication offers information about ==referenceText== and about ==duplicateText==. Thus, we can pass this information to the DiffPresentation and we get back a user interface as in the below example:@@todo redo this one[[[| browser |browser := GLMTabulator new.browser title: 'Duplication Browser'.browser row: #duplications; row: #diff span: 2.browser showOn: #duplications; using: [browser list].browser showOn: #diff; from: #duplications; using: [  browser diff display: [:dup |     Array with: dup referenceText with: dup duplicateText ]].browser openOn: MooseModel root allModels anyOne allDuplications.]]]+file://figures/glamour-diff-presentation.png+The DiffPresentation does not populate any port.!!!Dynamic presentationThe specification of Glamour transmissions and presentations are interpreted at creation time. Thus, by default we do not have the possibility to decide the presentation based on a given entity. The DynamicPresentation rectifies the situation by simply expecting a presentation returned from the block via the ==display:== message.There are two distinct classes of applications for DynamicPresentations: deciding the type or the amount of presentations based on the input entity.@@todo describe how the type can also be simulated with when: conditions on regular presentationsWhile the type of presentations can be simulated, deciding the number of presentations based on a given entity is not possible without a DynamicPresentation. The following code shows an example of how we could have a method browser that spawns multiple source code viewers when we select multiple methods.[[[| browser |browser := GLMTabulator new.browser title: 'Multi Methods Viewer'.browser   column: [:c | c row:  #classes; row: #methods];  column: #source.browser transmit to: #classes; andShow: [ :a  |  a list     title: 'Classes';    display: [:model | model allClasses ] ].browser transmit to: #methods; from: #classes; andShow: [ :a |  a list     title: [ :class | 'Methods from ', class name ];    beMultiple;     display: [ :class | class methods ];    format: [ :class | class name ] ].browser transmit to: #source; from: #methods; andShow: [ :a |  a dynamic with: [ :some :methods |     methods do: [ :each |      some text         title: each name asString;        display: [ each sourceText] ].    some stackedArrangement ] ].browser openOn: MooseModel root allModels last.]]]The above browser works on a model. For example, the picture below shows it spawned on the ArgoUML model.+file://figures/glamour-dynamic-example.png+!!!Custom presentationsPresentations are not limited to the default ones shipped with Glamour. Instead, if you desire a specific kind of interaction for your browser, you are encouraged to create a new Presentation.A simple example such a presentation would be one that would allow us to embed any widget from the underlying GUI framework. Glamour already comes with a MorphicPresentation which does nothing else but enable the display of Morphs provided by the Morphic framework of Pharo.@@todo change the example to use something else than the inspectorAs an example, suppose we want to reuse the Pharo Inspector by embedding it in a larger browser for inspecting classes from a model. For this we can simply retrieve the morph of the Inspector on each class as in the code below:[[[| browser |browser := GLMTabulator new.browser title: 'Class Inspector'.browser column: #classes; column: #inspector span: 2.browser transmit to: #classes; andShow: [ :a |  a list    title: 'Classes' ].browser transmit to: #inspector; from: #classes; andShow: [ :a |  a morph     title: [ :class | 'Inspector on ', class name];     display: [ :class |     PanelMorph new      layoutPolicy: ProportionalLayout new;		hResizing: #spaceFill;		vResizing: #spaceFill;      addAllMorphs: ( Inspector openAsMorphOn: class ) paneMorphs;      yourself ] ].browser openOn: MooseModel root allModels anyOne allModelClasses.]]]Executing the code leads to a user interface that spawns an Inspector for every selected class. Each of these Inspectors offers the same interaction as in the regular incarnation.+file://figures/glamour-morph-presentation.png+While it can be straightforward to build presentations that mirror the user interface widgets, it is desired to build presentations that provide a good abstraction for ''browsing''. Four things are important to keep in mind:#Presentations should focus primarily on data and on the goal of data interaction;#They should provide an API suitable for scripting;#Because ports are the means to propagate information to the outside of the pane, it is desirable for Presentations to populate at least one port (typically the ==#selection== one). Ideally, it should also populate and react to other ports as well.#Even if the Presentaion does not populate a port, it is advisable to at least allow for Actions to be defined for them. Thus, the user would have the option of using these Actions to populate ports or to change the model.!!Scripting browsersA Browser dictates the way in which the navigation flow is to be specified. We distinguish between two general types of browsers: #Explicit browsers enables us to control the creation of panes and transformations. Currently, there Glamour offers a single implementation of this type of browsers: the Tabulator (see *ref:tabulator*)#Implicit browsers come with a built in logic of the navigation flow, and only allow us to customize the presentations. There are two such browsers available: the Finder (see *ref:finder*) and the Accumulator (see *ref:accumulator*) Perhaps even more interesting is that Browsers can be nested allowing us to reuse complex navigation flows within even more complex ones. *ref:composition* provides more details.!!!TabulatorAs shown in *ref:../../glimpse*, a Tabulator is an explicit browser that allows us to:- create panes and organize them in a table layout, and- create transmissions between ports of these panes.The creation and laying out of panes is achieved via a simple scripting API similar to the algorithm behind the computation of a treemap visualization. The following UML diagram lists the relevant methods for this API.+file://figures/tabulator-layout.png+The creation of three panes at the same level can be achieved like:[[[browser column: #paneOne.browser column: #paneTwo.browser column: #paneThree.]]]or:[[[browser row: #paneOne.browser row: #paneTwo.browser row: #paneThree.]]]If we want to nest the last two into a parent cell that is placed at the same level as ==#paneOne==, we can achieve it in the following way:[[[browser column: #paneOne.browser column: [ :c |   c row: #paneTwo; c row: #paneThree ].]]]respectively: [[[browser row: #paneOne.browser row: [ :r |   r column: #paneTwo; r column: #paneThree ].]]]Thus, the ==row:== and ==column:== messages can be passed a block with one parameter that allows for further nesting. A row will allow us to create nested columns, while in a column we will be able to create nested rows. These parent rows and columns do not have a name because they are only an implementation detail related to the laying out of panes. Only the cells with names lead to the creation of panes that can later be accessed for transmissions.Once panes are created, we can deal with transmissions. A transmission can be created by simply calling ==transmit==. For example, defining a transmission that sets the presentations on #paneThree based on ports from paneOne and portB can be done via a construct like:[[[browser transmit   from: #paneOne;  from: #paneTwo->#portB;  fromOutside: #outsidePort;  to: #paneThree;  andShow: [ :a |     "specification of presentations" ].]]]More details about the specification of a transmission are presented in *ref:../../transmissions*. !!!Finder and PagerFinder is an implicit browser and it takes its name from the browser used to navigate through the file system of Mac OS X. Pager is a specialization that has the same API but offers a different scrolling user interface.The logic of the Finder goes as follows: - Panes are handled in an simple linked list, each having possibly one predecessor and one successor- The value from the #entity port of the pane containing the Finder, spawns the first pane.- Every time the #selection port of a pane is populated with a value, a new successor pane is created.- A transmission is created with the #selection of the previous pane as origin and the #entity port of the successor pane as destination.- Optionally, the user can specify further origin ports that should be taken into account.- This transmission sets the presentations that the user specifies.Perhaps this sounds more complicated than it really is. Let's see an example and build a rudimentary file browser like the one on Mac. Such a browser displays for each directory a list of all the direct children, and selecting a directory spawns another pane to the right:[[[browser := GLMFinder new.browser title: 'Files'.browser show: [ :a |  a list 	display: [ :directory | directory children ];   format: #basename;	when: [ :directory | directory exists ] ].]]]In essence, the only thing we specify is what gets shown in each pane. We can open the browser on an input directory file reference:[[[browser openOn: MooseModel root allModels first allModelNamespaces.]]]+file://figures/glamour-finder-example.png+ The Pager can be specified in exactly the same way, only for a different browser instance:[[[browser := GLMPager new.browser title: 'Files'.browser show: [ :a |  a list 	display: [ :directory | directory children ];   format: #basename;	when: [ :directory | directory exists ] ].]]]+file://figures/glamour-pager-example.png+ Please note how the scrollbar of the Pager shows the amount of panes more explicitly.@@todo forwarding!!!AccumulatorAccumulator is an implicit type of browser whose only behavior is to accumulate panes.Every time the #entity port of the parent pane is populated, the Accumulator searches through its panes to find one that corresponds the entity. If none is found, a new pane is created with the #entity populated. Just like in the case of the Finder, the user can specify the presentations that go in each pane.The main use case behind this type of browser is an editor like the Eclipse main view. For this purpose, it is typically combined with a Tabulator (more details about browser composition can be seen in *ref:../composition*). The snippet below shows an example:[[[| browser |browser := GLMTabulator new.browser column: #list; column: #details span: 2.browser title: 'Class Viewer'.browser transmit to: #list; andShow: [ :a |   a list     format: #name;    title: 'Classes' ].browser transmit to: #details; from: #list; andShowIfNone: [ :a |  | accumulator |  accumulator := GLMAccumulator new.  accumulator show: [ :some |     some title: #name.    some text       display: #formattedSourceText ].  a custom: accumulator ].]]]The overall browser is a Tabulator with two panes: one showing the list of all classes, and one showing the source code of each selected class in an Accumulator.The ==#selection== port of the left pane is linked with the ==#entity== port of the right pane. Thus, every time we select a class from the list on the left, the Accumulator will spawn a new tab. A particularity of this example is the use of ==andShowIfNone:== when specifying the transmission. Because the Accumulator is meant to accumulate, and not be replaced with every new transmission, we want the transmission to only install a new presentation when there is none in the target pane.Running the browser on all classes from the ArgoUML model, spawns a window as shown below.+file://figures/accumulator.png+The Accumulator also offers two more special ports: ==#entityToSelect==, and ==#activeEntity==.The ==#entityToSelect== port is meant to be used as an input port, and populating it with a value causes the renderer to try to select a tab that corresponds to the value. The behavior is similar to the one of ==#entity==, the difference being that it will not create a new tab if the tab does not yet exist.The ==#activeEntity== port is a special one that is populated with the value behind the currently selected tab.We can use these two ports can be used to completely simulate the Eclipse like behavior:- When we strong select (i.e., double click) the class from the left pane, we get a new tab. For this we connect the ==#strongSelection== port the list pane with the ==#entity== port from the details pane.- When we simply select the class from the left pane, we try to select the corresponding tab. To achieve this we connect the ==#selection== port from the left pane with the ==#entityToSelect== port from the details pane.- Finally, when we select a new tab, we select the corresponding element from the list. To this end, we connect the ==#activeEntity== port from the right pane with the ==#selection== port from the left pane.The code below shows the complete script:[[[| browser |browser := GLMTabulator new.browser column: #list; column: #details span: 2.browser title: 'Class Viewer'.browser transmit to: #list; andShow: [ :a |   a list     format: #name;    title: 'Classes' ].browser transmit to: #details; from: #list port: #strongSelection; andShowIfNone: [ :a |  | accumulator |  accumulator := GLMAccumulator new.  accumulator show: [ :some |     some title: #name.    some text       display: #formattedSourceText ].  a custom: accumulator ].browser transmit to: #details port: #entityToSelect; from: #list. browser transmit to: #list port: #selection; from: #details port: #activeEntity.]]]!!!Composing browsersBrowsers encapsulate a navigation flow, and in many cases we would like to reuse this flow in a larger context. This reuse is possible because browsers are presentations. Thus, they can be used within another browser by simply adding it as a presentation to a pane.Suppose that we would want to build a browser that given a starting method would allow us to navigate the chain of all invoking methods (similar to the Senders browser in Pharo). Given that we deal with a deep tree, we might want to use a Finder to navigate this structure. As possible result can be seen below.+file://figures/glamour-classic-chaser.png+In our example, we are actually dealing with two browsers:# an inner Finder that spawns the next pane with the invoking methods for each selected method, and# an overall Tabulator that shows the Finder on top, and the preview of the source code below.Let's build the two step by step. First, we build the ==innerBrowser==:[[[innerBrowser := GLMFinder new.innerBrowser show: [:a |   a list    title: [:each | 'Methods invoking ', each name ];    display: #invokingMethods ;    format: #mooseName ].]]]To see the source code for each method, we can now embed this browser in a Tabulator that previews the code for the currently selected method in a below pane. The embedding is achieved using ==custom:==:[[[browser := GLMTabulator new.browser title: [:each | 'Classic chaser on ', each mooseName ].browser row: #methods; row: #source.browser transmit to: #methods; andShow: [ :a |   a custom: innerBrowser ].browser transmit from: #methods; to: #source; andShow: [:a |  a text display: #sourceText ].]]]This works as follows. The inner Finder takes care of navigating through methods. Whenever a method is selected, it automatically sets the ==#selection== port of the pane holding the Finder, and this in turn triggers the transmission from the overall Tabulator.Executing the script on a Method entity reveals a browser like in the screenshot. For example, if you have an ArgoUML model loaded, you can execute it by:[[[browser openOn: (  MooseModel root allModels first allMethods     entityNamed: #'org::argouml::model::Facade.getName()')]]]One drawback of this browser is that at any point we can see the source code of only one method. To make it more interesting, we could turn the browser around a bit, and embed the Tabulator inside the Finder. For each pane in the Finder we would display two panes: one showing the current list of invoking methods, and one showing the code preview of the selected method. When a method is selected, we want to see its invoking methods to the right in the Finder. See the below screenshot for more details.+file://figures/glamour-chaser.png+In this example, we are dealing with the following browser:# an inner Tabulator that shows the invoking methods of a given method, and takes care of the source code preview of the selected method, and# an overall Finder browser that spawns the next pane for each selection.As before, first we build the ==innerBrowser==:[[[innerBrowser := GLMTabulator new.innerBrowser row: #methods; row: #source.innerBrowser transmit to: #methods; andShow: [ :a |   a list    title: [:each | 'Methods invoking ', each name ];    display: #invokingMethods ;    format: #mooseName ].innerBrowser transmit from: #methods; to: #source; andShow: [:a |  a text display: #sourceText ].]]]No magic here, just a plain Tabulator. While this works just fine as standalone, because the Tabulator is an explicit browser, it does not automatically populate the ==#selection== port like in the case of the Finder. Thus, when inside the Finder it we still need to inform the pane surrounding our browser that the ==#selection== port has changed. To do this, we have to explicitly export the ==#selection== port from the ==#methods== pane to the ==#selection== port of the ==#outer== pane:[[[innerBrowser transmit from: #methods; toOutsidePort: #selection.]]]Once this accomplished, we can now embed it in a Finder using ==custom:==:[[[browser  := GLMFinder new.browser title: [ :each | 'Reference browser on ', each mooseName ].browser show: [ :a |  a custom: innerBrowser ].]]]The new browser can be opened using the same code as before:[[[browser openOn: (  MooseModel root allModels first allMethods     entityNamed: #'org::argouml::model::Facade.getName()')]]]These examples show how we can compose browsers in different ways to obtain complex interactions. An important issue is to take care of what values go outside the browser. When embedding an implicit browser (e.g., Finder) we can directly rely on the ==#selection== port of the outer pane. When embedding an explicit browser (e.g., Tabulator) we need to explicitly populate the outer ports.!!Handling actionsEvery Presentation can be configured to react to Actions. Actions represent commands that are to be triggered by the user. Actions are described by three parameters: ==title==, ==key==, and ==icon==. An action with a title appears in the contextual menu of the presentation. If the action has an icon attached, it has the chance of appearing in the toolbar of a browser. An action with a key is mapped on a shortcut involving the platform modifier and the key (e.g., on Mac it is CMD\+key). The protocol to create actions has several selectors to accommodate the possible combinations. The most basic ones are as follows:- ==act:entitled:== sets the title;- ==act:icon:entitled:== sets the icon and the title;- ==act:on:== sets the shortcut.The ==act:== expects a block with several optional parameters: the first parameter is given by the presentation object, and the rest are populated by the input entities.By providing access to the presentation object, the Action also enable the population of the ports of the pane holding the presentation. For example, if we want to implement the Evaluator pane from the Moose Finder (see *ref:../../../externals/ui/finder*) we can write an action that takes the selected text, evaluates it and populates the ==#selection== port with the result:[[[finder show: [ :a |  a text    "..."    act: [ :text :entity |       text selection:        (Compiler evaluate: text selectedText for: entity logged: false)  ]      on: $o       entitled: 'Open script (o)' ].]]]The same action can also be written more succinctly:[[[finder show: [ :a |  a text    "..."    populate: #selection       on: $o       entitled: 'Open script (o)'       with: [ :text :entity |         Compiler evaluate: text selectedText for: entity logged: false  ] ].]]]@@note Given the access to the presentation object we have access to the entire browser, and thus we can also directly modify it. However, affecting directly the overall browser bypasses the mechanism of Glamour, breaks encapsulation and it makes the understanding and maintenance more difficult. Instead, it is preferred that each presentation affects only its own pane and let the propagation happen through explicit transmissions.There are several kinds of actions supported by Glamour. First, there are actions that are supposed to work for the entire presentation, and actions that are meant to work only contextually when there is a selection. These are specified using the following messages:- the ==act:== messages define actions for the entire presentation. These actions are typically rendered in the toolbar from the top-right of the presentation.- the ==selectionAct:== messages define actions that should be active only when there is a selection. These actions are typically mapped on the contextual menu.The above messages define static actions. That means that regardless of what the values of the ports are, these actions will always be available. However, at times, we can also decide to provide actions dynamically depending on the port values. This can be achieved through ==dynamicActions:== and ==dynamicActionsOnSelection:== messages. These messages receive a block that will be evaluated on the presentation and should return a list of GLMAction objects.@@note These messages are meant to be used as a last resort because they work with the internals of Glamour.!!Updating browsersWhen the objects browsed get changed, we need the browser to update and reflect the new state.In Glamour, there are two ways in which this is accomplished: #explicitly, by sending #update to a presentation, or #implicitly, by making a presentation listen to Announcements thrown by the objects.The explicit mechanism is simple and is typically accessible by means of actions. For example, to see the list of all models registered in the root model we could use a browser as shown below.[[[| browser |browser := GLMTabulator new.browser title: 'Model list with manual update'.browser column: #list.browser transmit to: #list; andShow: [:a |   a list     act: [:list | list update]       icon: GLMUIThemeExtraIcons glamorousRefresh      entitled: 'Update';    format: #name ].browser openOn: MooseModel root.]]]You can affect the root model by simply adding a new model:[[[MooseModel root add: MooseModel new.]]]The list does not show the new model. We can update the list by pressing the update icon.For the Announcement-based mechanism to work, you need an object that does raise Announcements. Once you have such an object, you can use ==GLMPresentation>>#updateOn: anAnnouncement from: anAnnouncer== to control what announcements should trigger the update of the presentation.Let us take an example. A MooseEntity sends several announcements when its inner structure changes. One of these Announcements is ==MooseEntityAdded==. However, because the MooseEntity is not an Announcer, it uses an announcer object to send the announcements. If you want to have a list of models from the root model updated every time a new model is added, you can register to the ==MooseEntityAdded== announcement sent by the ==model announcer==:[[[| browser |browser := GLMTabulator new.browser title: 'Model list with implicit update'.browser column: #list.browser transmit to: #list; andShow: [:a |   a list     format: #name;    updateOn: MooseEntityAdded from: [:model | model announcer ] ].]]]To watch the effect of an announcement, you can test it with:[[[MooseModel root add: MooseModel new.]]]@@todo validation!!RenderingThe Glamour model is formed by entities such as Browser, Pane, Presentation and Transmission (see *ref:../architecture*), and its main goal is to handle the abstract logic of the browser. Even if the main goal of Glamour is to produce actual browsers, this model is independent of the rendering technology.This decoupling is realized through a Visitor pattern. Every Pane and Presentations classes  understand ==renderGlamorouslyOn:==, and as an implementation, they delegate to a Renderer. It is then the job of the renderer to actually produce the actual widget that will appear on the screen and link it with the model of Glamour. The basic structure can be seen in the below class diagram.+file://figures/glamour-rendering.png+The Renderer class provides the abstract class that is meant to be subclassed by each new rendering platform. The default implementation uses Morphic, the default Pharo user interface framework, and it can be found in the GLMMorphicRenderer class.To better understand how the mechanism works, let us take a closer look at the code related to rendering a text presentation:[[[GLMTextPresentation>>renderGlamorouslyOn: aRenderer   self registerAnnouncements.  ^ aRenderer renderTextPresentation: self]]]The corresponding code in the MorphicRenderer uses a helper class:[[[renderTextPresentation: aTextPresentation   ^ GLMMorphicTextRenderer render: aTextPresentation from: self]]]Finally, the GLMMorphicTextRenderer provides the actual code:[[[GLMMorphicTextRenderer>>render: aPresentation  textModel := GLMTextModel new glamourPresentation: aPresentation "...".  textMorph := aPresentation highlightSmalltalk         ifTrue: [self smalltalkTextMorphForModel: textModel]        ifFalse: [self textMorphForModel: textModel].  "... more code that sets        the state of the presentation based on the morph events,       and the state of the morphs based on the internal Glamour announcements"  ^ textMorph]]]The implication of this design is twofold. First, if you want to support a new platform, you have to create a new subclass of Renderer. Second, if you create a new presentation or browser, you have to also provide the rendering code in all Renderers.!!ExamplesGlamour offers a self documenting browser with a set of examples covering the various features.You can get to this browser by executing:[[[GLMBasicExamples open]]]The browser offers several examples to the left. When selecting an example, it displays an instance of a browser and the source code for the browser.+file://figures/basic-examples-browser.png+