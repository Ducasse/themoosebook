!The FAMIX family of meta-modelsFAMIX is a family of meta-models for representing models related to various facets of software systems. These meta-models are typically geared towards enabling analysis and they provide a rich API that can be used for querying and navigation.The meta-models are implemented in Pharo, and because Pharo can be used as scripting language, the APIs defined by the meta-models also provide a query language.!!The core language-independent meta-modelThe Core of FAMIX consists of a language independent meta-model that can represent in a uniform way multiple object-oriented and procedural languages.The figure below offers a an overview of the class hierarchy, including some of the most used extensions. The hierarchy is to be read from left to right, the entities to the right being specializations of those to the left.+Famix hierarch>file://figures/famix-hierarchy.png+The diagram shows the hierarchy, but it does not show the attributes or relationships. To give you an idea of the amount of relations provided by FAMIX, take a look at the figure below (every light gray link represents a relationship between two entities):+Famix hierarchy>file://figures/famix-hierarchy-relationships.png+It can be daunting to try to understand FAMIX all at once. That is why in this chapter we take another route, and provide an overview of the most important parts. What does most important mean? These would be the parts that you are most likely to need in practice. That is not to say that the other parts are useless, but a significant amount of tasks can be accomplished with knowing only a subset of FAMIX.!!!An incorrect, but useful overviewIn most cases, you get enough information if you master the core types entities that model an object-oriented system. These are Namespace, Package, Class, Method, Attribute, and the relationships between them, namely Inheritance, Access and Invocation. The figure below provides an overview of these classes.+A useful Famix overview>file://figures/famix-overview.png+This is an incorrect overview from two points of view:# It does not show all entities. For example, a Method has also a Parameters and LocalVariables.# At places, it shows direct relationships when in reality they happen through inheritance. For example, the Access points to an Attribute, while in reality it points to a superclass (StructuralEntity).However, while incorrect, this picture is also useful because for most practical purposes it is all you need. Let us go through it step by step.There isn't much to say about most of the picture. Most of it goes along the lines of mirroring  code concepts. For example, classes have methods, and methods belong to classes. More worthy of being noticed is the use of explicit entities to model relationships. Thus, we have:- Inheritance models as its names says object-oriented inheritance between two classes and: the subclass, and the superclass.- Access denotes a connection between a behavioral entity (often a Method in object-oriented systems) and an structural entity (often an Attribute).- Invocation is a connection between one source and one or more target behavioral entities (often Methods). There can be more than one target behavioral entity because in dynamic languages we cannot identify statically with 100% accuracy the target of an invocation. See *ref:../invocation* for more details.Another point that often generates confusion is the presence of both Namespace and Package in the meta-model. These are similar entities, but they model different things. Namespaces have a semantic meaning in the language so they influence the unique name of the entity, while a Package are physical entities for packaging:- In Smalltalk the two are explicitly different.- In C\+\+ we have explicit Namespaces, but not so explicit Packages. A C\+\+ namespace has no other responsibility beside providing a lexical scope for the contained classes and funcions.- In Java, we have both Namespace (what you define in your Java source), and Package (the folder structure), but they happen to overlap in naming (although one is with . and the other one is with /). As a consequence, people tend to see them as packages only. It is for this reason, that Java extractors map Java packages to FAMIX Namespaces. Some can also mirror the same information in terms of FAMIX Packages.Please note the missing arrows on the associations. This is not a mistake. In FAMIX, all associations are bidirectional. Let us take an example. Given the model from our running example, we have:[[[aClass := model allClasses entityNamed: #'org::argouml::ui::Critic'.aClass methods first parentType == aClass"--> true"]]]In other words, we can navigate from a class to its methods and back using only unary methods. Furthermore, these relationships are cached in the entities, and thus the traversal works fast.The reason for this mechanism is that we want to offer the possibility of traversing the model from any point to any point. This is particularly useful when we use the API as a query language.@@todo naming convention for attributes!!!TypesTypes are central to object-oriented systems. In this section, we take a closer look at the type hierarchy and related classes.The root of the hierarchy is simply Type. This is a generic class representing a type in an object-oriented language. It can have many Methods and Attributes.A type can also take part in inheritance relationships. This happens by means of Inheritance entities that connect pairs of types. Multiple inheritance is modeled by simply having multiple inheritance objects connecting the same subclass with multiple superclasses.Type has several specializations for specific kinds of types. The most prominent is provided by Class. This models a typical class in Smalltalk, Java or C\+\+, but it also models a Java interface (by means of the isInterface boolean property).A PrimitiveType is just that: a primitive type. For example, int or char will be modeled using PrimitiveType entities.ParameterizedType and ParameterizableClass model Java generics or C\+\+ templates. In particular, a ParameterizableClass represents the generic definition, while the ParameterizedType represents the actual usage of the generic in a specific context.Let me provide an example based on the following Java snippet:[[[public class ClassA<B,C> {...}...public ClassA<ActualTypeA,ActualTypeB> anAttribute;]]]In this case, ==ClassA== will be represented by a ParameterizableClass, and the declared type of anAttribute will be an actual ParameterizedType linking to ==ClassA==. Furthermore, ==B== and ==C== will be ParameterTypes, and the corresponding slots from the ParameterizedType will point to the actual types ==ActualTypeA== and ==ActualTypeB==.+Types>file://figures/famix-types.png+!!!The invocationThe Invocation entity models a static invocation between two behavioral entities. Typical behavioral entities are Method and Function, the difference between them being that a Method belongs to a Class, while a Function belongs directly to a Namespace.This entity is one of the most complex in FAMIX, mostly due to it being able to accommodate both statically and dynamically typed languages.+Invocation>file://figures/famix-invocation.png+!!!The annotationsMost programming languages have some means to add information to source code that has no direct impact on the execution.Let us take two examples: [[[smalltalkMethodAnnotated  <primitive: 'primAnyBitFromTo' module:'LargeIntegers'>]]][[[language=java@Test(timeout = 500)public void javaMethodAnnotated()]]]@@todo more on the examples: what is the type, what is the instance, and how they relate to the entity+Annotations>file://figures/famix-annotations.png+!!!Famix generic query API@@todo examples, composability, main concepts!!Meta-model extensions@@todo navigation, actions@@todo focus on unary methods!!The Meta BrowserFAMIX is a family of meta-models and it is meant to be extended. To browse the landscape of the FAMIX implementation at any point in time, we have a dedicated browser that offers a logical view of the meta-descriptions.The Meta Browser can be can be spawned from the Moose menu or by executing:[[[ MooseModel browseMeta]]]The browser shows the hierarchy of classes to the top-left. Selecting an class shows both the references to other classes and the primitive properties. At the bottom, a map of the overall class hierarchies is provided as a Mondrian visualization. The current selection is shown on the map in red. Furthermore, the comment of the current selection is shown to the right.The picture below shows the browser focused on the ==SourcedEntity== and on the ==sourceAnchor== property.+Meta browser>file://figures/meta-browser.png+